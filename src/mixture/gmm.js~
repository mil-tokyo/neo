var nodejs = (typeof window === 'undefined');

if (nodejs) {
    var AgentSmith = require('../../agent_smith/src/agent_smith');
    var AgentSmithML = require('../agent_smith_ml');
    require('./mixture');
}

var $M = AgentSmith.Matrix;

AgentSmithML.Mixture.GMM = function(n_components, n_iter, thresh){
    this.n_components = typeof n_components === "undefined" ? 1 : n_components;
    this.n_iter = typeof n_iter === "undefined" ? 1 : n_iter;
    this.thresh = typeof thresh === "undefined" ? 1 : thresh;
}

AgentSmithML.Mixture.GMM.prototype.fit(X){
    var n_samples = X.rows;
    var n_features = X.cols;

    this.initParams(n_features)
    var oldLogLikelihood = 0
    var newLogLikelihood = 0
    for(var i=0; i<n_iter; i++){
	var responsibility = this.expectationStep(X);
	this.maximizationStep(X, responsibility);
	newLogLikelihood = this.calcLogLikelihood(X);
	if(checkConvergnce(oldLogLikelihood, newLogLikelihood, this.thresh)){
	    break;
	}
	oldLogLikelihood = newLogLikelihood;
    }
    
}

AgentSmithML.Mixture.GMM.prototype.calcLogLikelihood(X){
    n_samples = X.rows;
    loglikelihood = 0;
    for(i=0; i<n_samples; i++){
	var x = $M.extract(X, i, 0, 1, n_features)
	var likelihood = 0;
	for(k=0; k<this.n_components; k++){
	    likelihood += getGaussProbability(this.weights.data[k], this.means[k], this.covars[k]);
	}
	loglikelihood += Math.log(likelihood)
    }
    return loglikelihood
}
AgentSmithML.Mixture.GMM.prototype.expectationStep(X){
    var n_samples = X.rows;
    var n_features = X.cols;
    var responsibility = new $M(n_samples, this.n_components)
    responsibility.zeros(0);

    for(var i=0; i<n_samples; i++){
	var x = $M.extract(X, i, 0, 1, n_features);
	for(var k=0; k<this.n_components; k++){
	    var posterior = getGaussProbability(this.weights.data[k], this.means[k], this.covars[k], x);
	    responsibility.set(i, k, posterior)
	}
    }
    responsibility = $M.div(responsibility, $M.sumEachRow(responsibility))	
    return responsibility
}

AgentSmithML.Mixture.GMM.prototype.maximizationStep(X, responsibility){
    var n_samples = X.rows;
    var Nk = $M.sumEachCol(responsibility);
    this.weights = Nk.times( 1.0 / n_samples);

    for(var i=0; i<n_samples; i++){
	var x = $M.extract(X, i, 0, 1, n_features);
	for(var k=0; k<this.n_components; k++){
	    this.means[k] = $M.add(this.mean[k], x.times(responsibility.get(i, k)))
	}
    }

    for(var k=0; k<this.n_components; k++){
	this.means[k] = this.means[k].times( 1.0 / Nk.data[k]);
    }

    for(var i=0; i<n_samples; i++){
	var x = $M.extract(X, i, 0, 1, n_features);
	for(var k=0; k<this.n_components; k++){
	    var sub = $M.sub(x, this.means[k]);
	    this.covars[k] = $M.add(this.covars[k], $M.mul(sub, sub.t()).times( responsibility.get(i, k) ))
	}
    }

    for(var k=0; k<this.n_components; k++){
	this.covars[k] = this.covars[k].times( 1.0 / Nk.data[k]);
    }

}

AgentSmith.Mixture.GMM.prototype.initParams(n_features){
    this.weights = new $M(1, this.n_components);
    this.weights.zeros( 1.0 / this.n_components );

    this.means = [];
    this.covars = [];

    for(var k=0; k<this.n_components; k++){
	mean = new $M(n_features, 1);
	mean.zeros( 1.0 / n_features );
	this.means.push(mean);

	covar = new $M(n_features, n_features);
	covar.zeros( 1.0 / (n_features * n_features) );
	this.covars.push(covar);
    }	
}



function getGaussProbability(weight, mean, covar, x){
    var m = x.rows;
    var sub = $M.sub(x, mean);
    var normalization_term = 1.0 / (Math.pow(Math.sqrt(2*Math.PI), m)* Math.sqrt(covar.det()));
    var gauss = $M.mul($M.mul(sub.t(), covar.inverse()), sub).times(-0.5).map(Math.exp);
    return $M.mul(weight * normalization_term, gauss) 
}

function checkConvergence(old_val, new_val, tol){
    if(Math.abs(old_val - new_val) , tol){
	return true
    }
    return false
}
